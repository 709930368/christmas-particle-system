<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ğŸ­ ç³–æœç²’å­æ‰‹åŠ¿äº¤äº’ç³»ç»Ÿ (1-4 æ‰‹åŠ¿åŠ¨æ€ç„¦ç‚¹)</title>
    <style>
        /* æ ·å¼ä¿æŒä¸å˜ */
        :root {
            --primary-color: #ffcc00; /* ç³–æœé»„ */
            --accent-color: #ff0033; /* ç³–æœçº¢ */
            --bg-color: #050505;
            --glass-bg: rgba(20, 20, 20, 0.6);
            --border: 1px solid rgba(255, 255, 255, 0.1);
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: 'Inter', 'Segoe UI', sans-serif;
            user-select: none;
        }

        #canvas-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1;
        }

        #loader {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: #000; z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: var(--primary-color); transition: opacity 0.5s;
        }
        .loader-ring {
            width: 60px; height: 60px; border: 4px solid rgba(255, 204, 0, 0.1);
            border-top: 4px solid var(--primary-color); border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .ui-layer {
            position: absolute; z-index: 10; pointer-events: none; width: 100%; height: 100%;
        }

        .camera-hud {
            position: absolute; bottom: 30px; left: 30px; width: 240px; height: 180px;
            background: #000; border-radius: 12px; overflow: hidden; border: var(--border);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5); pointer-events: auto;
        }
        #input-video {
            width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); opacity: 0.7;
        }
        .hud-status {
            position: absolute; bottom: 10px; left: 10px; font-size: 12px; color: #fff;
            background: rgba(0,0,0,0.6); padding: 4px 8px; border-radius: 4px;
            display: flex; align-items: center; gap: 6px;
        }
        .status-dot {
            width: 8px; height: 8px; background: #ff3333; border-radius: 50%; box-shadow: 0 0 5px #ff3333;
            transition: background 0.3s;
        }
        .status-dot.active { background: var(--primary-color); box-shadow: 0 0 5px var(--primary-color); }

        .header-info {
            position: absolute; top: 30px; left: 50%; transform: translateX(-50%);
            text-align: center; color: white; pointer-events: none;
        }
        h1 { margin: 0; font-size: 1.5rem; letter-spacing: 2px; font-weight: 300; opacity: 0.9; }
        p.subtitle { margin: 8px 0 0; font-size: 0.9rem; color: rgba(255,255,255,0.8); }

        .fs-btn {
            position: absolute; bottom: 30px; right: 30px; pointer-events: auto;
            background: var(--glass-bg); border: var(--border); color: white;
            padding: 12px 24px; border-radius: 30px; cursor: pointer; backdrop-filter: blur(10px);
            transition: all 0.3s; font-size: 14px; text-transform: uppercase; letter-spacing: 1px;
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">
        <div class="loader-ring"></div>
        <div>åŠ è½½ä¸­... å¯åŠ¨è§†è§‰å¼•æ“å’Œ3Dç¯å¢ƒ</div>
        <div id="loader-status" style="font-size: 12px; margin-top: 10px; color: #999">æ­£åœ¨åˆå§‹åŒ– 3D æ¸²æŸ“...</div>
    </div>

    <div id="canvas-container"></div>

    <div class="ui-layer">
        <div class="header-info">
            <h1>ğŸ­ ç³–æœç²’å­äº’åŠ¨ç³»ç»Ÿ (å›¾ç‰‡æ¨¡å¼)</h1>
            <p class="subtitle" id="gesture-hint">æ¡æ‹³ï¼šç²’å­èšé›†æˆç³–æœæ ‘ | å¼ å¼€æ‰‹æŒï¼šç²’å­æ‰©æ•£æˆé£é›ª | æ¯”å‡º 1-4 èšç„¦å›¾ç‰‡</p>
        </div>

        <div class="camera-hud">
            <video id="input-video" playsinline></video>
            <div class="hud-status">
                <div class="status-dot" id="status-dot"></div>
                <span id="status-text">æ­£åœ¨æœå¯»æ‰‹åŠ¿...</span>
            </div>
        </div>

        <button class="fs-btn" onclick="toggleFullScreen()">â›¶ Fullscreen</button>
    </div>

    <script>
        const THREE = window.THREE;
        const Camera = window.Camera;
        const Hands = window.Hands;

        const config = {
            particleCount: 18000, 
            particleSize: 0.15,
            handSensitivity: 3.0,
            smoothness: 0.1,
            idleAnimation: true,
        };

        const state = {
            targetShapePositions: [],
            scatteredPositions: [], 
            targetColors: [],       
            handInfluence: 0,       
            smoothedInfluence: 0,
            time: 0,
            numericGesture: 0, // 0=æ— æ•°å­—, 1-4=å›¾ç‰‡ç¼–å·
        };

        let scene, camera, renderer, particles, geometry, material;
        let imageSprites = []; // ç”¨äºå­˜å‚¨ 4 å¼ å›¾ç‰‡çš„ THREE.Sprite å¯¹è±¡

        async function init() {
            if (initScene()) {
                initParticles();
                generateShape('christmas_tree'); 
                addImageSprites(); 
                
                document.getElementById('loader-status').innerHTML = 'æ­£åœ¨å¯åŠ¨æ‘„åƒå¤´å’Œ AI æ¨¡å‹...';
                try {
                    await initComputerVision();
                    document.getElementById('loader').style.opacity = 0;
                    setTimeout(() => document.getElementById('loader').style.display = 'none', 500);
                } catch (e) {
                    document.getElementById('loader-status').innerHTML = 'âš ï¸ æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼è¯·æ£€æŸ¥ HTTPS åè®®æˆ–æµè§ˆå™¨è®¾ç½®ã€‚é”™è¯¯: ' + (e.message || e.name || 'Unknown Error');
                    console.error("CV Init Failed", e);
                }
            } else {
                 document.getElementById('loader-status').innerHTML += ' âŒ æ— æ³•åˆ›å»º 3D æ¸²æŸ“ç¯å¢ƒã€‚è¯·å°è¯•æ›´æ¢æµè§ˆå™¨ã€‚';
            }
            animate();
        }

        function initScene() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.02);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 8; 

            try {
                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.setClearColor(0x050505, 1); 
                container.appendChild(renderer.domElement);
                scene.rotation.y = Math.PI;

            } catch (e) {
                 document.getElementById('loader-status').innerHTML = 'âš ï¸ WebGL æ¸²æŸ“å™¨åˆ›å»ºå¤±è´¥ã€‚';
                 console.error("Renderer setup failed:", e);
                 return false;
            }

            window.addEventListener('resize', onWindowResize);
            return true;
        }

        function initParticles() {
            geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(config.particleCount * 3);
            const colors = new Float32Array(config.particleCount * 3);
            
            for (let i = 0; i < config.particleCount * 3; i++) {
                positions[i] = (Math.random() - 0.5) * 20; 
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/spark1.png');

            material = new THREE.PointsMaterial({
                size: config.particleSize,
                map: sprite,
                vertexColors: true,
                blending: THREE.AdditiveBlending, 
                depthWrite: false,
                transparent: true,
                opacity: 0.8
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        // --- ç³–æœç²’å­ç”Ÿæˆ (æœªå˜åŠ¨) ---
        function generateShape(type) {
            const target = [];
            const targetColors = [];
            const scattered = [];
            const count = config.particleCount;

            const treeHeight = 6; 
            const baseRadius = 3;  
            const totalLayers = 4;
            const layerHeight = treeHeight / totalLayers;
            const verticalGap = layerHeight * 0.25; 

            const CROWN_COLORS = [
                new THREE.Color(0xFFCC00), new THREE.Color(0xFF6600), new THREE.Color(0xFF0033), 
            ];
            const ORNAMENT_COLORS = [
                new THREE.Color(0xFFFFFF), new THREE.Color(0xFFCC00), new THREE.Color(0xFF0033), 
            ];
            const STAR_COLOR = new THREE.Color(0xFFFFFF); 
            const TRUNK_COLOR = new THREE.Color(0x964B00); 

            for (let i = 0; i < count; i++) {
                let x, y, z;
                let color;
                
                const randomVal = Math.random();

                if (randomVal < 0.02) { 
                    y = treeHeight / 2 + 0.5; 
                    const r = Math.random() * 0.3;
                    const theta = Math.random() * Math.PI * 2;
                    x = r * Math.cos(theta);
                    z = r * Math.sin(theta);
                    color = STAR_COLOR;

                } else if (randomVal < 0.82) { // æ ‘å† 
                    const layerIndex = Math.floor(Math.random() * totalLayers); 
                    const layerBottomY = layerIndex * layerHeight - treeHeight / 2;
                    
                    const activeHeight = layerHeight - verticalGap;
                    y = layerBottomY + Math.random() * activeHeight;

                    const currentLayerNormalized = layerIndex / totalLayers;
                    const nextLayerNormalized = (layerIndex + 1) / totalLayers;

                    const bottomRadius = baseRadius * (1 - currentLayerNormalized) * 0.95;
                    const topRadius = baseRadius * (1 - nextLayerNormalized) * 0.95;
                    
                    const vertRatioInLayer = (y - layerBottomY) / layerHeight; 
                    const desiredRadius = bottomRadius + (topRadius - bottomRadius) * vertRatioInLayer;
                    const actualRadius = desiredRadius * (Math.random() * 0.9);
                    
                    const theta = Math.random() * Math.PI * 2;
                    x = actualRadius * Math.cos(theta);
                    z = actualRadius * Math.sin(theta);
                    
                    y += (Math.random() - 0.5) * 0.5;
                    color = CROWN_COLORS[i % CROWN_COLORS.length]; 

                } else if (randomVal < 0.98) { // è£…é¥°
                    const heightFactor = Math.random();
                    y = (heightFactor * treeHeight - (treeHeight / 2));
                    
                    const normalizedY = (y + treeHeight / 2) / treeHeight;
                    const treeRadiusAtY = baseRadius * (1 - normalizedY);
                    
                    const r = treeRadiusAtY * (1.1 + Math.random() * 0.1); 
                    const angle = Math.random() * Math.PI * 2;
                    
                    x = r * Math.cos(angle);
                    z = r * Math.sin(angle);
                    
                    color = ORNAMENT_COLORS[i % ORNAMENT_COLORS.length];

                } else { // æ ‘å¹²
                    const trunkWidth = 0.8;
                    x = (Math.random() - 0.5) * trunkWidth;
                    z = (Math.random() - 0.5) * trunkWidth;
                    y = -treeHeight / 2 - Math.random() * 1; 
                    color = TRUNK_COLOR;
                }
                
                target.push(x, y, z);
                targetColors.push(color.r, color.g, color.b);

                scattered.push(
                    (Math.random() - 0.5) * 20, 
                    (Math.random() - 0.5) * 20, 
                    (Math.random() - 0.5) * 20
                );
            }
            
            state.targetShapePositions = new Float32Array(target);
            state.targetColors = new Float32Array(targetColors);
            state.scatteredPositions = new Float32Array(scattered);
        }

        // --- å›¾åƒå¯¹è±¡åˆå§‹åŒ– (4å¼ , æœªå˜åŠ¨) ---
        function addImageSprites() {
            const urls = [
                'images/1.jpg', 
                'images/2.jpg', 
                'images/3.jpg', 
                'images/4.jpg' 
            ];

            const loader = new THREE.TextureLoader();
            const radius = 6; 
            const spriteSize = 2;

            for (let i = 0; i < 4; i++) {
                const texture = loader.load(urls[i]);
                
                // ï¼ï¼ï¼å…³é”®ä¿®æ”¹ï¼šç¦ç”¨æ·±åº¦æµ‹è¯•
                const material = new THREE.SpriteMaterial({ 
                    map: texture, 
                    transparent: true, 
                    opacity: 1.0,      
                    blending: THREE.NormalBlending,
                    
                    // <--- æ–°å¢/ä¿®æ”¹ï¼šç¦ç”¨æ·±åº¦æµ‹è¯•
                    depthTest: false, // ç¦ç”¨æ·±åº¦æµ‹è¯•
                    depthWrite: false, // ç¦ç”¨æ·±åº¦å†™å…¥
                    // ------------------------------------
                });
                
                const sprite = new THREE.Sprite(material);
                sprite.scale.set(spriteSize, spriteSize, 1);
                
                const angle = i * (2 * Math.PI / 4); 
                sprite.position.x = radius * Math.cos(angle);
                sprite.position.z = radius * Math.sin(angle);
                sprite.position.y = 0; 

                scene.add(sprite);
                imageSprites.push({
                    sprite: sprite,
                    initialPosition: sprite.position.clone(),
                    initialScale: spriteSize,
                    angle: angle,
                    targetScale: spriteSize,
                    targetX: sprite.position.x,
                    targetY: sprite.position.y,
                    targetZ: sprite.position.z
                });
            }
        }


        function animate() {
            requestAnimationFrame(animate);
            state.time += 0.01;

            if (!renderer || !particles) return;

            state.smoothedInfluence += (state.handInfluence - state.smoothedInfluence) * config.smoothness;
            
            const positions = geometry.attributes.position.array;
            const colors = geometry.attributes.color.array;

            const influenceWeight = state.smoothedInfluence;

            // --- ç²’å­åŠ¨ç”» (æœªå˜åŠ¨) ---
            for (let i = 0; i < config.particleCount; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                const modelX = state.targetShapePositions[ix];
                const scatterX = state.scatteredPositions[ix];

                const tx = modelX + (scatterX - modelX) * influenceWeight;
                const ty = state.targetShapePositions[iy] + (state.scatteredPositions[iy] - state.targetShapePositions[iy]) * influenceWeight;
                const tz = state.targetShapePositions[iz] + (state.scatteredPositions[iz] - state.targetShapePositions[iz]) * influenceWeight;

                const transitionSpeed = 0.08; 
                positions[ix] += (tx - positions[ix]) * transitionSpeed;
                positions[iy] += (ty - positions[iy]) * transitionSpeed;
                positions[iz] += (tz - positions[iz]) * transitionSpeed;

                if (influenceWeight < 0.1 && config.idleAnimation) {
                    const noise = 0.05;
                    positions[ix] += Math.sin(state.time + i) * noise;
                    positions[iy] += Math.cos(state.time * 0.8 + i) * noise;
                }
                
                if (influenceWeight > 0.8) {
                    positions[iy] -= 0.05; 
                    if (positions[iy] < -10) positions[iy] = 10;
                }
                
                const targetR = state.targetColors[ix];
                const targetG = state.targetColors[iy];
                const targetB = state.targetColors[iz];
                
                const lerpFactor = influenceWeight * 0.7; 
                
                colors[ix] = targetR + (1 - targetR) * lerpFactor;
                colors[iy] = targetG + (1 - targetG) * lerpFactor;
                colors[iz] = targetB + (1 - targetB) * lerpFactor;
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
            
            scene.rotation.y += 0.005;

            // --- å›¾åƒåŠ¨ç”»å’Œäº¤äº’ (åŠ¨æ€ç„¦ç‚¹ä¿æŒ) ---
            const orbitSpeed = 0.01;
            const focusIndex = state.numericGesture - 1; 

            imageSprites.forEach((data, index) => {
                const isFocused = index === focusIndex;
                const sprite = data.sprite;
                
                if (!isFocused) {
                    // ç¯ç»•æ—‹è½¬
                    data.angle += orbitSpeed;
                    const radius = 6;
                    data.targetX = radius * Math.cos(data.angle);
                    data.targetZ = radius * Math.sin(data.angle);
                    data.targetY = data.initialPosition.y;
                    data.targetScale = data.initialScale;
                } else {
                    // åŠ¨æ€ç„¦ç‚¹æ•ˆæœ
                    // ï¼ï¼ï¼å…³é”®ä¿®æ”¹ï¼šå°† Z è½´ä½ç½®è°ƒæ•´å¾—æ›´è¿‘ (8 -> 2.5)ï¼Œä½¿å…¶æ›´å±…ä¸­
                    data.targetX = Math.sin(state.time * 2) * 0.5; 
                    data.targetY = Math.cos(state.time * 1.5) * 0.5; 
                    data.targetZ = 2.5 + Math.sin(state.time * 4) * 0.2; // Z è½´æ‹‰è¿‘
                    data.targetScale = 5; 
                }

                // å¹³æ»‘è¿‡æ¸¡
                const smoothFactor = 0.15;
                sprite.position.x += (data.targetX - sprite.position.x) * smoothFactor;
                sprite.position.y += (data.targetY - sprite.position.y) * smoothFactor;
                sprite.position.z += (data.targetZ - sprite.position.z) * smoothFactor;
                
                const currentScale = sprite.scale.x;
                const newScale = currentScale + (data.targetScale - currentScale) * smoothFactor;
                sprite.scale.set(newScale, newScale, 1);
            });


            renderer.render(scene, camera);
        }

        async function initComputerVision() {
            const videoElement = document.getElementById('input-video');
            
            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandsResults);

            const camera = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 320,
                height: 240
            });

            await camera.start();
        }

        // è¾…åŠ©å‡½æ•°ï¼šåˆ¤æ–­æ‰‹æŒ‡æ˜¯å¦ä¼¸ç›´ (Yè½´åˆ¤æ–­)
        function isFingerStraight(landmarks, fingerBase, fingerTip) {
            const tip = landmarks[fingerTip];
            const mcp = landmarks[fingerBase]; 
            return tip.y < mcp.y;
        }

        // --- æ–°å¢è¾…åŠ©å‡½æ•°ï¼šåˆ¤æ–­æ‹‡æŒ‡æ˜¯å¦å¼¯æ›²/è´´åˆ ---
        function isThumbFolded(landmarks) {
            const thumbTip = landmarks[4];
            const thumbMCP = landmarks[2];
            
            // æ£€æŸ¥æ‹‡æŒ‡æŒ‡å°–åˆ°æŒéª¨ (MCP) çš„è·ç¦»ã€‚å¦‚æœè·ç¦»å°äºæŸä¸ªé˜ˆå€¼ï¼Œåˆ™è®¤ä¸ºæ‹‡æŒ‡æ˜¯å¼¯æ›²æˆ–è´´åˆçš„ã€‚
            // ç»éªŒé˜ˆå€¼ï¼š0.15 (åœ¨ MediaPipe çš„æ ‡å‡†åŒ–åæ ‡ç³»ä¸­)
            const thumbDistance = Math.sqrt(
                Math.pow(thumbTip.x - thumbMCP.x, 2) + 
                Math.pow(thumbTip.y - thumbMCP.y, 2) +
                Math.pow(thumbTip.z - thumbMCP.z, 2)
            );
            return thumbDistance < 0.15; 
        }
        
        // --- æ‰‹åŠ¿è¯†åˆ«é€»è¾‘ (å†²çªè§£å†³) ---
        function onHandsResults(results) {
            const statusDot = document.getElementById('status-dot');
            const statusText = document.getElementById('status-text');
            const hint = document.getElementById('gesture-hint');

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                statusDot.classList.add('active');
                
                const landmarks = results.multiHandLandmarks[0];
                const thumb = landmarks[4]; 
                const pinky = landmarks[20]; 
                
                // 1. æ¡æ‹³/å¼ å¼€ (æ‰©æ•£/èšé›†) æ£€æµ‹ - çµæ•åº¦å¢å¼º
                const distance = Math.sqrt(Math.pow(thumb.x - pinky.x, 2) + Math.pow(thumb.y - pinky.y, 2) + Math.pow(thumb.z - pinky.z, 2));

                // ä¿æŒå¢å¼ºçš„çµæ•åº¦ï¼šæ¡æ‹³æ—¶æ›´å®¹æ˜“è¾¾åˆ° 0
                let factor = (distance - 0.08) * 5.0; 
                let scatterInfluence = Math.max(0, Math.min(1, factor)); 


                // 2. ä¸¥æ ¼æ•°å­—æ‰‹åŠ¿æ£€æµ‹ (1-4)
                let gestureNumber = 0;
                const thumbFolded = isThumbFolded(landmarks);
                
                // åªæœ‰å½“æ‹‡æŒ‡æ˜¯å¼¯æ›²/è´´åˆæ—¶ï¼Œæ‰å°è¯•è¯†åˆ«æ•°å­— 1-4
                if (thumbFolded) {
                    const indexUp = isFingerStraight(landmarks, 5, 8);
                    const middleUp = isFingerStraight(landmarks, 9, 12);
                    const ringUp = isFingerStraight(landmarks, 13, 16);
                    const pinkyUp = isFingerStraight(landmarks, 17, 20);

                    // 1: ä»…é£ŸæŒ‡ä¼¸å‡º
                    if (indexUp && !middleUp && !ringUp && !pinkyUp) {
                        gestureNumber = 1; 
                    } 
                    // 2: é£ŸæŒ‡å’Œä¸­æŒ‡ä¼¸å‡º
                    else if (indexUp && middleUp && !ringUp && !pinkyUp) {
                        gestureNumber = 2; 
                    } 
                    // 3: é£ŸæŒ‡ã€ä¸­æŒ‡å’Œæ— åæŒ‡ä¼¸å‡º
                    else if (indexUp && middleUp && ringUp && !pinkyUp) {
                        gestureNumber = 3; 
                    } 
                    // 4: é£ŸæŒ‡åˆ°å°æŒ‡ä¼¸å‡º (å››æŒ‡å…¨ä¼¸)
                    else if (indexUp && middleUp && ringUp && pinkyUp) {
                        gestureNumber = 4; 
                    }
                }
                
                state.numericGesture = gestureNumber;

                // 3. å†²çªè§£å†³ä¸çŠ¶æ€æ›´æ–°
                if (state.numericGesture > 0) {
                    // **æ•°å­—æ‰‹åŠ¿ä¼˜å…ˆï¼šé”å®šç²’å­ä¸ºèšé›†çŠ¶æ€**
                    state.handInfluence = 0; 
                    statusText.innerText = `è¿½è¸ªæˆåŠŸ - ğŸ–ï¸ æ•°å­— ${state.numericGesture}`;
                    hint.innerText = `å›¾ç‰‡ ${state.numericGesture} åŠ¨æ€èšç„¦ä¸­!`;
                } else {
                    // **æ— æ•°å­—æ‰‹åŠ¿æ—¶ï¼Œæ‰§è¡Œæ¡æ‹³/å¼ å¼€æ£€æµ‹**
                    state.handInfluence = scatterInfluence;
                    const particleState = state.handInfluence > 0.5 ? 'å¼ å¼€ (æ‰©æ•£)' : 'æ¡æ‹³ (èšé›†)';
                    statusText.innerText = `è¿½è¸ªæˆåŠŸ - ${particleState}`;
                    hint.innerText = `æ‰©æ•£å¼ºåº¦: ${(state.handInfluence * 100).toFixed(0)}% | æ¯”å‡º 1-4 èšç„¦å›¾ç‰‡`;
                }


            } else {
                statusDot.classList.remove('active');
                statusText.innerText = "ç­‰å¾…æ‰‹åŠ¿ - Searching...";
                state.handInfluence = 0; 
                state.numericGesture = 0; 
                hint.innerText = "è¯·åœ¨æ‘„åƒå¤´å‰å±•ç¤ºæ‰‹æŒ (é»˜è®¤ä¸ºæ¡æ‹³æ¨¡å¼)";
            }
        }

        function onWindowResize() {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        window.toggleFullScreen = function() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                if (document.exitFullscreen) document.exitFullscreen();
            }
        };

        init();
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ğŸ„ åœ£è¯ç²’å­æ‰‹åŠ¿äº¤äº’ç³»ç»Ÿ</title>
    <style>
        :root {
            --primary-color: #00ff88; /* åœ£è¯ç»¿ */
            --accent-color: #ff3333; /* é“ƒé“›çº¢ */
            --bg-color: #050505;
            --glass-bg: rgba(20, 20, 20, 0.6);
            --border: 1px solid rgba(255, 255, 255, 0.1);
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: 'Inter', 'Segoe UI', sans-serif;
            user-select: none;
        }

        /* ç”»å¸ƒå®¹å™¨ */
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* åŠ è½½åŠ¨ç”» */
        #loader {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: #000;
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: var(--primary-color);
            transition: opacity 0.5s;
        }
        .loader-ring {
            width: 60px; height: 60px;
            border: 4px solid rgba(0, 255, 136, 0.1);
            border-top: 4px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* UI è¦†ç›–å±‚ */
        .ui-layer {
            position: absolute;
            z-index: 10;
            pointer-events: none;
            width: 100%;
            height: 100%;
        }

        /* æ‘„åƒå¤´ HUD */
        .camera-hud {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 240px;
            height: 180px;
            background: #000;
            border-radius: 12px;
            overflow: hidden;
            border: var(--border);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            pointer-events: auto;
        }
        #input-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* é•œåƒ */
            opacity: 0.7;
        }
        .hud-status {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-size: 12px;
            color: #fff;
            background: rgba(0,0,0,0.6);
            padding: 4px 8px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .status-dot {
            width: 8px; height: 8px;
            background: #ff3333;
            border-radius: 50%;
            box-shadow: 0 0 5px #ff3333;
            transition: background 0.3s;
        }
        .status-dot.active { background: #00ff88; box-shadow: 0 0 5px #00ff88; }

        /* é¡¶éƒ¨æ ‡é¢˜ä¸æç¤º */
        .header-info {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: white;
            pointer-events: none;
        }
        h1 { margin: 0; font-size: 1.5rem; letter-spacing: 2px; font-weight: 300; opacity: 0.9; }
        p.subtitle { margin: 8px 0 0; font-size: 0.9rem; color: rgba(255,255,255,0.8); }

        /* å…¨å±æŒ‰é’® */
        .fs-btn {
            position: absolute;
            bottom: 30px;
            right: 30px;
            pointer-events: auto;
            background: var(--glass-bg);
            border: var(--border);
            color: white;
            padding: 12px 24px;
            border-radius: 30px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.3s;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .fs-btn:hover { background: rgba(255,255,255,0.2); }

    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://unpkg.com/three@0.160.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.160.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.160.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">
        <div class="loader-ring"></div>
        <div>åŠ è½½ä¸­... å¯åŠ¨è§†è§‰å¼•æ“å’Œ3Dç¯å¢ƒ</div>
        <div id="loader-status" style="font-size: 12px; margin-top: 10px; color: #999">è¯·æˆäºˆæ‘„åƒå¤´æƒé™ä»¥è¿›è¡Œäº¤äº’</div>
    </div>

    <div id="canvas-container"></div>

    <div class="ui-layer">
        <div class="header-info">
            <h1>åœ£è¯ç²’å­äº¤äº’ç³»ç»Ÿ ğŸ„</h1>
            <p class="subtitle" id="gesture-hint">æ¡æ‹³ï¼šç²’å­èšé›†æˆåœ£è¯æ ‘ | å¼ å¼€æ‰‹æŒï¼šç²’å­æ‰©æ•£æˆé£é›ª</p>
        </div>

        <div class="camera-hud">
            <video id="input-video" playsinline></video>
            <div class="hud-status">
                <div class="status-dot" id="status-dot"></div>
                <span id="status-text">æ­£åœ¨æœå¯»æ‰‹åŠ¿...</span>
            </div>
        </div>

        <button class="fs-btn" onclick="toggleFullScreen()">â›¶ Fullscreen</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // å¼•å…¥è¾‰å…‰åº“ï¼ˆè™½ç„¶ä¸æ˜¯æ¨¡å—ï¼Œä½†ä¸ºäº†ä½¿ç”¨ THREE.js çš„å‘½åç©ºé—´ï¼Œæ”¾åœ¨è¿™é‡Œï¼‰
        const EffectComposer = window.THREE.EffectComposer;
        const RenderPass = window.THREE.RenderPass;
        const UnrealBloomPass = window.THREE.UnrealBloomPass;


        const config = {
            particleCount: 15000,
            particleSize: 0.15,
            baseColor: '#00ff44', // åœ£è¯æ ‘ç»¿è‰²
            accentColor: '#ff0000', // é“ƒé“›çº¢è‰²
            shape: 'christmas_tree',
            handSensitivity: 3.0,
            smoothness: 0.1,
            idleAnimation: true,
            bloomStrength: 1.5,
            bloomThreshold: 0.0,
        };

        const state = {
            targetShapePositions: [],
            scatteredPositions: [], // æ–°å¢ï¼šé£é›ªç›®æ ‡ä½ç½®
            targetColors: [],       // æ–°å¢ï¼šç²’å­ç›®æ ‡é¢œè‰²
            handInfluence: 0,       // 0 (æ¡æ‹³/èšé›†) åˆ° 1 (å¼ å¼€/æ‰©æ•£)
            smoothedInfluence: 0,
            time: 0
        };

        let scene, camera, renderer, particles, geometry, material, controls, composer, bloomPass;
        let positionsAttribute;


        async function init() {
            if (initScene()) {
                initParticles();
                generateShape('christmas_tree'); 
                initGUI(); 
                
                // ç¡®ä¿ Three.js åˆå§‹åŒ–å®Œæˆåå†å¯åŠ¨ CV
                try {
                    await initComputerVision();
                    document.getElementById('loader').style.opacity = 0;
                    setTimeout(() => document.getElementById('loader').style.display = 'none', 500);
                } catch (e) {
                    document.getElementById('loader-status').innerHTML = 'âš ï¸ æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥ HTTPS åè®®ï¼';
                    console.error("CV Init Failed", e);
                }
            }
            animate();
        }

        function initScene() {
            const container = document.getElementById('canvas-container');

            if (!container || !window.WebGLRenderingContext) {
                 document.getElementById('loader-status').innerHTML = 'âš ï¸ è®¾å¤‡ä¸æ”¯æŒ WebGL 3D æ¸²æŸ“ï¼';
                 return false;
            }

            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.02);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 25;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;
            controls.enableZoom = true; // å…è®¸ç¼©æ”¾

            // --- è¾‰å…‰æ•ˆæœ (Unreal Bloom Pass) ---
            const renderPass = new RenderPass(scene, camera);
            bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight), 
                config.bloomStrength, 
                0.4, 
                config.bloomThreshold
            );
            
            composer = new EffectComposer(renderer);
            composer.addPass(renderPass);
            composer.addPass(bloomPass);

            window.addEventListener('resize', onWindowResize);
            return true;
        }

        function initParticles() {
            geometry = new THREE.BufferGeometry();
            
            const positions = new Float32Array(config.particleCount * 3);
            const colors = new Float32Array(config.particleCount * 3);
            
            for (let i = 0; i < config.particleCount * 3; i++) {
                // åˆå§‹åŒ–éšæœºæ•£å¸ƒåœ¨ç©ºé—´
                positions[i] = (Math.random() - 0.5) * 50;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3)); // åˆå§‹é¢œè‰²å°†åœ¨ generateShape ä¸­è®¾ç½®

            const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/spark1.png');

            material = new THREE.PointsMaterial({
                size: config.particleSize,
                map: sprite,
                vertexColors: true,
                blending: THREE.AdditiveBlending, // ç”¨äºè¾‰å…‰æ•ˆæœ
                depthWrite: false,
                transparent: true,
                opacity: 0.8
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            positionsAttribute = geometry.attributes.position;
        }

        // --- A. æ ¸å¿ƒä¿®æ”¹ï¼šç”Ÿæˆåœ£è¯æ ‘æ¨¡å‹ ---
        function generateShape(type) {
            config.shape = type;
            const target = [];
            const targetColors = [];
            const scattered = [];
            const count = config.particleCount;

            const treeColor = new THREE.Color(config.baseColor);
            const accentColor = new THREE.Color(config.accentColor);
            const trunkColor = new THREE.Color(0x795548); // æ£•è‰²æ ‘å¹²

            const treeHeight = 20;
            const baseRadius = 10;
            const layers = 5;

            for (let i = 0; i < count; i++) {
                let x, y, z;
                let color;
                
                const randomVal = Math.random();

                if (randomVal < 0.85) { // 85% ç²’å­ç”¨äºæ ‘å† 
                    const layer = Math.floor(Math.random() * layers);
                    // æ ‘å†  Y ä½ç½® (ä»åº•éƒ¨çš„-10åˆ°é¡¶éƒ¨çš„+10)
                    const layerY = (layer / layers) * treeHeight - (treeHeight / 2) + 2; 
                    
                    // åŠå¾„éšç€Yè½´ï¼ˆå±‚æ•°ï¼‰çš„å¢åŠ è€Œå‡å° (é”¥å½¢)
                    const currentRadius = baseRadius * (1 - (layer / layers) * 0.9) * (Math.random() * 0.5 + 0.5);

                    const theta = Math.random() * Math.PI * 2;
                    const r = Math.random() * currentRadius;
                    
                    x = r * Math.cos(theta);
                    z = r * Math.sin(theta);
                    // å¢åŠ å‚ç›´éšæœºæ€§ï¼Œæ¨¡æ‹Ÿå¤šå±‚æ ‘å† ç»“æ„
                    y = layerY + (Math.random() - 0.5) * 2.5; 
                    
                    color = treeColor;

                } else if (randomVal < 0.95) { // 10% ç²’å­ç”¨äºé“ƒé“›/è£…é¥° (ç™½è‰²/çº¢è‰²)
                    const angle = Math.random() * Math.PI * 2;
                    const heightFactor = Math.random(); // 0åˆ°1
                    const r = (baseRadius * 0.8) * (1 - heightFactor);
                    
                    x = r * Math.cos(angle);
                    z = r * Math.sin(angle);
                    y = (heightFactor * treeHeight - (treeHeight / 2)) + Math.sin(state.time * 2 + i) * 0.5; // è½»å¾®æ™ƒåŠ¨
                    
                    color = (i % 3 === 0) ? new THREE.Color(0xFFD700) : accentColor; // é‡‘è‰²å’Œçº¢è‰²äº¤æ›¿

                } else { // 5% ç²’å­ç”¨äºæ ‘å¹²/åº•åº§
                    const trunkWidth = 2;
                    x = (Math.random() - 0.5) * trunkWidth;
                    z = (Math.random() - 0.5) * trunkWidth;
                    y = -treeHeight / 2 - Math.random() * 4;
                    color = trunkColor;
                }
                
                target.push(x, y, z);
                targetColors.push(color.r, color.g, color.b);

                // é£é›ªæ‰©æ•£ä½ç½® (å‡åŒ€éšæœºåˆ†å¸ƒ)
                scattered.push(
                    (Math.random() - 0.5) * 80, 
                    (Math.random() - 0.5) * 80, 
                    (Math.random() - 0.5) * 80
                );
            }
            
            state.targetShapePositions = new Float32Array(target);
            state.targetColors = new Float32Array(targetColors);
            state.scatteredPositions = new Float32Array(scattered);
        }

        function animate() {
            requestAnimationFrame(animate);
            state.time += 0.01;

            // B. æ‰‹åŠ¿æ§åˆ¶é€»è¾‘ï¼šå¹³æ»‘è¿‡æ¸¡
            state.smoothedInfluence += (state.handInfluence - state.smoothedInfluence) * config.smoothness;
            
            // æ‰©æ•£å¼ºåº¦ï¼šinfluence=0 æ—¶ expansion=1 (èšé›†); influence=1 æ—¶ expansion>1 (æ‰©æ•£)
            const expansionFactor = state.smoothedInfluence * config.handSensitivity * 20; 

            const positions = geometry.attributes.position.array;
            const colors = geometry.attributes.color.array;

            // åŒºåˆ†ç›®æ ‡ä½ç½®ï¼šæ ¹æ®å¹³æ»‘å½±å“åŠ›å†³å®šæ˜¯æ¨¡å‹è¿˜æ˜¯é£é›ª
            const finalTargetPositions = new Float32Array(config.particleCount * 3);
            const influenceWeight = state.smoothedInfluence; // 0åˆ°1

            for (let i = 0; i < config.particleCount; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                const modelX = state.targetShapePositions[ix];
                const scatterX = state.scatteredPositions[ix];

                // Lerp åœ¨æ¨¡å‹ç›®æ ‡ä½ç½® å’Œ é£é›ªç›®æ ‡ä½ç½® ä¹‹é—´
                // ç»“æœæ˜¯ï¼šå½±å“å› å­è¶Šå¤§ï¼Œç²’å­ç›®æ ‡è¶Šé è¿‘æ•£å¸ƒä½ç½®
                const tx = modelX + (scatterX - modelX) * influenceWeight;
                const ty = state.targetShapePositions[iy] + (state.scatteredPositions[iy] - state.targetShapePositions[iy]) * influenceWeight;
                const tz = state.targetShapePositions[iz] + (state.scatteredPositions[iz] - state.targetShapePositions[iz]) * influenceWeight;


                // ç²’å­è‡ªèº«çš„è¿åŠ¨ï¼ˆå¹³æ»‘è¿‡æ¸¡ï¼‰
                const transitionSpeed = 0.08; 
                positions[ix] += (tx - positions[ix]) * transitionSpeed;
                positions[iy] += (ty - positions[iy]) * transitionSpeed;
                positions[iz] += (tz - positions[iz]) * transitionSpeed;


                // æ¡æ‹³æ—¶å¢åŠ å¾®å°èºåŠ¨
                if (influenceWeight < 0.1 && config.idleAnimation) {
                    const noise = 0.05;
                    positions[ix] += Math.sin(state.time + i) * noise;
                    positions[iy] += Math.cos(state.time * 0.8 + i) * noise;
                }
                
                // é£é›ªçŠ¶æ€ä¸‹ï¼Œå¢åŠ è½»å¾®ä¸‹è½å’ŒZè½´éšæœºç§»åŠ¨
                if (influenceWeight > 0.8) {
                    positions[iy] -= 0.05; 
                    if (positions[iy] < -40) positions[iy] = 40; // å¾ªç¯
                    positions[iz] += Math.sin(state.time * 0.5 + i) * 0.005;
                }
                
                // é¢œè‰²å˜åŒ–ï¼šæ‰©æ•£æ—¶é¢œè‰²å˜ç™½ï¼ˆæ¨¡æ‹Ÿé›ªèŠ±å…‰èŠ’ï¼‰
                const r = state.targetColors[ix] + influenceWeight * 0.5;
                const g = state.targetColors[iy] + influenceWeight * 0.5;
                const b = state.targetColors[iz] + influenceWeight * 0.5;

                colors[ix] = Math.min(1, r);
                colors[iy] = Math.min(1, g);
                colors[iz] = Math.min(1, b);
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
            
            controls.update();
            
            // ä½¿ç”¨ EffectComposer æ¸²æŸ“ä»¥åº”ç”¨è¾‰å…‰
            composer.render();
        }

        async function initComputerVision() {
            const videoElement = document.getElementById('input-video');
            
            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandsResults);

            const camera = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 320,
                height: 240
            });

            await camera.start();
        }

        // --- B. æ ¸å¿ƒä¿®æ”¹ï¼šå¼ å¼€/æ¡æ‹³é€»è¾‘ ---
        function onHandsResults(results) {
            const statusDot = document.getElementById('status-dot');
            const statusText = document.getElementById('status-text');
            const hint = document.getElementById('gesture-hint');

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                statusDot.classList.add('active');
                
                const landmarks = results.multiHandLandmarks[0];
                const thumb = landmarks[4]; // æ‹‡æŒ‡å°–
                const pinky = landmarks[20]; // å°æŒ‡å°–
                
                // è®¡ç®—æ‹‡æŒ‡å’Œå°æŒ‡çš„å½’ä¸€åŒ–è·ç¦»
                const distance = Math.sqrt(Math.pow(thumb.x - pinky.x, 2) + Math.pow(thumb.y - pinky.y, 2) + Math.pow(thumb.z - pinky.z, 2));

                // å½’ä¸€åŒ–åˆ° 0 åˆ° 1
                let factor = (distance - 0.1) * 4.0; // 0.1 æ˜¯æ¡æ‹³è·ç¦»çš„ä¼°è®¡å€¼
                factor = Math.max(0, Math.min(1, factor));

                // æ¡æ‹³æ—¶ distance å° (factorâ‰ˆ0)ï¼Œå¼ å¼€æ—¶ distance å¤§ (factorâ‰ˆ1)
                // state.handInfluence 0=èšé›† (æ¡æ‹³)ï¼›1=æ‰©æ•£ (å¼ å¼€)
                state.handInfluence = factor; 

                statusText.innerText = `è¿½è¸ªæˆåŠŸ - ${state.handInfluence > 0.5 ? 'å¼ å¼€' : 'æ¡æ‹³'}`;
                hint.innerText = `æ‰©æ•£å¼ºåº¦: ${(state.handInfluence * 100).toFixed(0)}% | æ¡æ‹³ï¼šèšé›† ğŸ„`;

            } else {
                statusDot.classList.remove('active');
                statusText.innerText = "ç­‰å¾…æ‰‹åŠ¿ - Searching...";
                state.handInfluence = 0; // æœªæ£€æµ‹åˆ°æ—¶ï¼Œé»˜è®¤èšé›†ï¼ˆæ¡æ‹³çŠ¶æ€ï¼‰
                hint.innerText = "è¯·åœ¨æ‘„åƒå¤´å‰å±•ç¤ºæ‰‹æŒ (é»˜è®¤ä¸ºæ¡æ‹³æ¨¡å¼)";
            }
        }

        function initGUI() {
            const gui = new GUI({ title: 'æ§åˆ¶å°' });
            gui.domElement.style.top = '20px';
            gui.domElement.style.right = '20px';

            const styleFolder = gui.addFolder('è§†è§‰å‚æ•° (Visuals)');
            styleFolder.addColor(config, 'baseColor').name('æ ‘å¹²é¢œè‰² (ç»¿)');
            styleFolder.addColor(config, 'accentColor').name('é“ƒé“›é¢œè‰² (çº¢)');
            styleFolder.add(config, 'particleSize', 0.05, 0.5).name('ç²’å­å¤§å°').onChange(v => material.size = v);

            const bloomFolder = gui.addFolder('C. è¾‰å…‰æ•ˆæœ (Bloom)');
            bloomFolder.add(config, 'bloomStrength', 0.1, 5.0).name('è¾‰å…‰å¼ºåº¦').onChange(v => bloomPass.strength = v);
            bloomFolder.add(config, 'bloomThreshold', 0.0, 1.0).name('è¾‰å…‰é˜ˆå€¼').onChange(v => bloomPass.threshold = v);
            bloomFolder.add(config, 'smoothness', 0.01, 0.5).name('ç²’å­å¹³æ»‘åº¦');

            const handFolder = gui.addFolder('æ‰‹åŠ¿æ§åˆ¶ (Gesture)');
            handFolder.add(config, 'handSensitivity', 1, 5).name('æ‰©æ•£æ•æ„Ÿåº¦');
            handFolder.add(config, 'idleAnimation').name('æ¨¡å‹èºåŠ¨');

            styleFolder.open();
            bloomFolder.open();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight); // è°ƒæ•´ composer
        }

        window.toggleFullScreen = function() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                if (document.exitFullscreen) document.exitFullscreen();
            }
        };

        init();
    </script>
</body>
</html>

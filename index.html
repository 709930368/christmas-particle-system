<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ğŸ„ åœ£è¯ç²’å­æ‰‹åŠ¿äº¤äº’ç³»ç»Ÿ (æœ€å°ä½“ç§¯ï¼Œæœ€å¼ºç»“æ„)</title>
    <style>
        /* æ ·å¼ä¿æŒä¸å˜ */
        :root {
            --primary-color: #00ff88; 
            --accent-color: #ff3333; 
            --bg-color: #050505;
            --glass-bg: rgba(20, 20, 20, 0.6);
            --border: 1px solid rgba(255, 255, 255, 0.1);
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: 'Inter', 'Segoe UI', sans-serif;
            user-select: none;
        }

        #canvas-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1;
        }

        #loader {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: #000; z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: var(--primary-color); transition: opacity 0.5s;
        }
        .loader-ring {
            width: 60px; height: 60px; border: 4px solid rgba(0, 255, 136, 0.1);
            border-top: 4px solid var(--primary-color); border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .ui-layer {
            position: absolute; z-index: 10; pointer-events: none; width: 100%; height: 100%;
        }

        .camera-hud {
            position: absolute; bottom: 30px; left: 30px; width: 240px; height: 180px;
            background: #000; border-radius: 12px; overflow: hidden; border: var(--border);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5); pointer-events: auto;
        }
        #input-video {
            width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); opacity: 0.7;
        }
        .hud-status {
            position: absolute; bottom: 10px; left: 10px; font-size: 12px; color: #fff;
            background: rgba(0,0,0,0.6); padding: 4px 8px; border-radius: 4px;
            display: flex; align-items: center; gap: 6px;
        }
        .status-dot {
            width: 8px; height: 8px; background: #ff3333; border-radius: 50%; box-shadow: 0 0 5px #ff3333;
            transition: background 0.3s;
        }
        .status-dot.active { background: #00ff88; box-shadow: 0 0 5px #00ff88; }

        .header-info {
            position: absolute; top: 30px; left: 50%; transform: translateX(-50%);
            text-align: center; color: white; pointer-events: none;
        }
        h1 { margin: 0; font-size: 1.5rem; letter-spacing: 2px; font-weight: 300; opacity: 0.9; }
        p.subtitle { margin: 8px 0 0; font-size: 0.9rem; color: rgba(255,255,255,0.8); }

        .fs-btn {
            position: absolute; bottom: 30px; right: 30px; pointer-events: auto;
            background: var(--glass-bg); border: var(--border); color: white;
            padding: 12px 24px; border-radius: 30px; cursor: pointer; backdrop-filter: blur(10px);
            transition: all 0.3s; font-size: 14px; text-transform: uppercase; letter-spacing: 1px;
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">
        <div class="loader-ring"></div>
        <div>åŠ è½½ä¸­... å¯åŠ¨è§†è§‰å¼•æ“å’Œ3Dç¯å¢ƒ</div>
        <div id="loader-status" style="font-size: 12px; margin-top: 10px; color: #999">æ­£åœ¨åˆå§‹åŒ– 3D æ¸²æŸ“...</div>
    </div>

    <div id="canvas-container"></div>

    <div class="ui-layer">
        <div class="header-info">
            <h1>Policeä»¬åœ£è¯å¿«ä¹ ğŸ„</h1>
            <p class="subtitle" id="gesture-hint">æ¡æ‹³ï¼šç²’å­èšé›†æˆåœ£è¯æ ‘ | å¼ å¼€æ‰‹æŒï¼šç²’å­æ‰©æ•£æˆé£é›ª</p>
        </div>

        <div class="camera-hud">
            <video id="input-video" playsinline></video>
            <div class="hud-status">
                <div class="status-dot" id="status-dot"></div>
                <span id="status-text">æ­£åœ¨æœå¯»æ‰‹åŠ¿...</span>
            </div>
        </div>

        <button class="fs-btn" onclick="toggleFullScreen()">â›¶ Fullscreen</button>
    </div>

    <script>
        const THREE = window.THREE;
        const Camera = window.Camera;
        const Hands = window.Hands;

        const config = {
            particleCount: 18000, 
            particleSize: 0.15,
            handSensitivity: 3.0,
            smoothness: 0.1,
            idleAnimation: true,
        };

        const state = {
            targetShapePositions: [],
            scatteredPositions: [], 
            targetColors: [],       
            handInfluence: 0,       
            smoothedInfluence: 0,
            time: 0
        };

        let scene, camera, renderer, particles, geometry, material;

        async function init() {
            if (initScene()) {
                initParticles();
                generateShape('christmas_tree'); 
                
                document.getElementById('loader-status').innerHTML = 'æ­£åœ¨å¯åŠ¨æ‘„åƒå¤´å’Œ AI æ¨¡å‹...';
                try {
                    await initComputerVision();
                    document.getElementById('loader').style.opacity = 0;
                    setTimeout(() => document.getElementById('loader').style.display = 'none', 500);
                } catch (e) {
                    document.getElementById('loader-status').innerHTML = 'âš ï¸ æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼è¯·æ£€æŸ¥ HTTPS åè®®æˆ–æµè§ˆå™¨è®¾ç½®ã€‚é”™è¯¯: ' + (e.message || e.name || 'Unknown Error');
                    console.error("CV Init Failed", e);
                }
            } else {
                 document.getElementById('loader-status').innerHTML += ' âŒ æ— æ³•åˆ›å»º 3D æ¸²æŸ“ç¯å¢ƒã€‚è¯·å°è¯•æ›´æ¢æµè§ˆå™¨ã€‚';
            }
            animate();
        }

        function initScene() {
            const container = document.getElementById('canvas-container');
            if (!container || !window.WebGLRenderingContext) {
                 document.getElementById('loader-status').innerHTML = 'âš ï¸ è®¾å¤‡ä¸æ”¯æŒ WebGL 3D æ¸²æŸ“ï¼';
                 return false;
            }

            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.02);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            // è°ƒæ•´ç›¸æœºä½ç½®ä»¥é€‚åº”æ›´å°çš„ä½“ç§¯
            camera.position.z = 8; 

            try {
                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.setClearColor(0x050505, 1); 
                container.appendChild(renderer.domElement);
                
                scene.rotation.y = Math.PI;

            } catch (e) {
                 document.getElementById('loader-status').innerHTML = 'âš ï¸ WebGL æ¸²æŸ“å™¨åˆ›å»ºå¤±è´¥ã€‚è¯¦ç»†é”™è¯¯: ' + (e.message || 'æœªçŸ¥');
                 console.error("Renderer setup failed:", e);
                 return false;
            }

            window.addEventListener('resize', onWindowResize);
            return true;
        }

        function initParticles() {
            geometry = new THREE.BufferGeometry();
            
            const positions = new Float32Array(config.particleCount * 3);
            const colors = new Float32Array(config.particleCount * 3);
            
            for (let i = 0; i < config.particleCount * 3; i++) {
                // æ•£å¸ƒèŒƒå›´è¿›ä¸€æ­¥å‡å°
                positions[i] = (Math.random() - 0.5) * 20; 
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/spark1.png');

            material = new THREE.PointsMaterial({
                size: config.particleSize,
                map: sprite,
                vertexColors: true,
                blending: THREE.AdditiveBlending, 
                depthWrite: false,
                transparent: true,
                opacity: 0.8
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        // --- A. æ ¸å¿ƒä¿®æ”¹ï¼šæœ€å°ä½“ç§¯å’Œæœ€å¼ºç»“æ„æ„Ÿ ---
        function generateShape(type) {
            config.shape = type;
            const target = [];
            const targetColors = [];
            const scattered = [];
            const count = config.particleCount;

            // --- ä½“ç§¯å†æ¬¡å‡åŠ ---
            const treeHeight = 6; 
            const baseRadius = 3;  
            const totalLayers = 4; // æ˜ç¡®çš„å±‚æ•°
            const layerHeight = treeHeight / totalLayers; // 1.5
            const verticalGap = layerHeight * 0.25; // 25% çš„å±‚é«˜ä½œä¸ºå‚ç›´ç©ºéš™ (0.375)

            // --- é¢œè‰²è°ƒè‰²æ¿ ---
            const CROWN_COLORS = [
                new THREE.Color(0x00FF88), new THREE.Color(0x33CCFF), 
                new THREE.Color(0xFFFF00), new THREE.Color(0xFF6600), 
            ];
            const ORNAMENT_COLORS = [
                new THREE.Color(0xFF0000), new THREE.Color(0xFFD700), 
                new THREE.Color(0x00FFFF), new THREE.Color(0xFFFFFF), 
                new THREE.Color(0xFF00FF), 
            ];
            const STAR_COLOR = new THREE.Color(0xFFFFFF); 
            const TRUNK_COLOR = new THREE.Color(0x795548); 

            for (let i = 0; i < count; i++) {
                let x, y, z;
                let color;
                
                const randomVal = Math.random();

                if (randomVal < 0.02) { // 2% ç²’å­ç”¨äºæ˜Ÿ
                    y = treeHeight / 2 + 0.5; 
                    const r = Math.random() * 0.3; // æ˜Ÿå½¢ç¼©å°
                    const theta = Math.random() * Math.PI * 2;
                    x = r * Math.cos(theta);
                    z = r * Math.sin(theta);
                    color = STAR_COLOR;

                } else if (randomVal < 0.82) { // 80% ç²’å­ç”¨äºæ ‘å† 
                    const layerIndex = Math.floor(Math.random() * totalLayers); 
                    const layerBottomY = layerIndex * layerHeight - treeHeight / 2;
                    
                    // --- å…³é”®ï¼šåªåœ¨æœ‰æ•ˆé«˜åº¦ç”Ÿæˆç²’å­ï¼Œç•™å‡ºç©ºéš™ ---
                    const activeHeight = layerHeight - verticalGap;
                    y = layerBottomY + Math.random() * activeHeight;

                    // åœ†å°è®¡ç®—
                    const currentLayerNormalized = layerIndex / totalLayers;
                    const nextLayerNormalized = (layerIndex + 1) / totalLayers;

                    const bottomRadius = baseRadius * (1 - currentLayerNormalized) * 0.95; // 95%çš„é”¥å½¢
                    const topRadius = baseRadius * (1 - nextLayerNormalized) * 0.95;
                    
                    // ç²’å­åœ¨å±‚å†…çš„å‚ç›´æ¯”ä¾‹
                    const vertRatioInLayer = (y - layerBottomY) / layerHeight; 
                    
                    const desiredRadius = bottomRadius + (topRadius - bottomRadius) * vertRatioInLayer;
                    
                    const actualRadius = desiredRadius * (Math.random() * 0.9); // å¡«å……
                    
                    const theta = Math.random() * Math.PI * 2;
                    x = actualRadius * Math.cos(theta);
                    z = actualRadius * Math.sin(theta);
                    
                    y += (Math.random() - 0.5) * 0.5; // å‡å°å‚ç›´æŠ–åŠ¨
                    
                    color = CROWN_COLORS[i % CROWN_COLORS.length]; 

                } else if (randomVal < 0.98) { // 16% ç²’å­ç”¨äºè£…é¥°
                    const heightFactor = Math.random();
                    y = (heightFactor * treeHeight - (treeHeight / 2));
                    
                    const normalizedY = (y + treeHeight / 2) / treeHeight;
                    const treeRadiusAtY = baseRadius * (1 - normalizedY);
                    
                    const r = treeRadiusAtY * (1.1 + Math.random() * 0.1); 
                    const angle = Math.random() * Math.PI * 2;
                    
                    x = r * Math.cos(angle);
                    z = r * Math.sin(angle);
                    
                    color = ORNAMENT_COLORS[i % ORNAMENT_COLORS.length];

                } else { // 2% ç²’å­ç”¨äºæ ‘å¹²
                    const trunkWidth = 0.8; // æ ‘å¹²æ›´ç»†
                    x = (Math.random() - 0.5) * trunkWidth;
                    z = (Math.random() - 0.5) * trunkWidth;
                    y = -treeHeight / 2 - Math.random() * 1; 
                    color = TRUNK_COLOR;
                }
                
                target.push(x, y, z);
                targetColors.push(color.r, color.g, color.b);

                // é£é›ªæ•£å¸ƒèŒƒå›´è¿›ä¸€æ­¥å‡å°
                scattered.push(
                    (Math.random() - 0.5) * 20, 
                    (Math.random() - 0.5) * 20, 
                    (Math.random() - 0.5) * 20
                );
            }
            
            state.targetShapePositions = new Float32Array(target);
            state.targetColors = new Float32Array(targetColors);
            state.scatteredPositions = new Float32Array(scattered);
        }

        function animate() {
            requestAnimationFrame(animate);
            state.time += 0.01;

            if (!renderer || !particles) return;

            state.smoothedInfluence += (state.handInfluence - state.smoothedInfluence) * config.smoothness;
            
            const positions = geometry.attributes.position.array;
            const colors = geometry.attributes.color.array;

            const influenceWeight = state.smoothedInfluence;

            for (let i = 0; i < config.particleCount; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                const modelX = state.targetShapePositions[ix];
                const scatterX = state.scatteredPositions[ix];

                const tx = modelX + (scatterX - modelX) * influenceWeight;
                const ty = state.targetShapePositions[iy] + (state.scatteredPositions[iy] - state.targetShapePositions[iy]) * influenceWeight;
                const tz = state.targetShapePositions[iz] + (state.scatteredPositions[iz] - state.targetShapePositions[iz]) * influenceWeight;

                const transitionSpeed = 0.08; 
                positions[ix] += (tx - positions[ix]) * transitionSpeed;
                positions[iy] += (ty - positions[iy]) * transitionSpeed;
                positions[iz] += (tz - positions[iz]) * transitionSpeed;

                if (influenceWeight < 0.1 && config.idleAnimation) {
                    const noise = 0.05;
                    positions[ix] += Math.sin(state.time + i) * noise;
                    positions[iy] += Math.cos(state.time * 0.8 + i) * noise;
                }
                
                if (influenceWeight > 0.8) {
                    positions[iy] -= 0.05; 
                    if (positions[iy] < -10) positions[iy] = 10; // å¾ªç¯èŒƒå›´å†æ¬¡å‡å°
                }
                
                const targetR = state.targetColors[ix];
                const targetG = state.targetColors[iy];
                const targetB = state.targetColors[iz];
                
                const lerpFactor = influenceWeight * 0.7; 
                
                colors[ix] = targetR + (1 - targetR) * lerpFactor;
                colors[iy] = targetG + (1 - targetG) * lerpFactor;
                colors[iz] = targetB + (1 - targetB) * lerpFactor;
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
            
            scene.rotation.y += 0.005;

            renderer.render(scene, camera);
        }

        async function initComputerVision() {
            const videoElement = document.getElementById('input-video');
            
            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandsResults);

            const camera = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 320,
                height: 240
            });

            await camera.start();
        }

        function onHandsResults(results) {
            const statusDot = document.getElementById('status-dot');
            const statusText = document.getElementById('status-text');
            const hint = document.getElementById('gesture-hint');

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                statusDot.classList.add('active');
                
                const landmarks = results.multiHandLandmarks[0];
                const thumb = landmarks[4]; 
                const pinky = landmarks[20]; 
                
                const distance = Math.sqrt(Math.pow(thumb.x - pinky.x, 2) + Math.pow(thumb.y - pinky.y, 2) + Math.pow(thumb.z - pinky.z, 2));

                let factor = (distance - 0.1) * 4.0; 
                factor = Math.max(0, Math.min(1, factor));

                state.handInfluence = factor; 

                statusText.innerText = `è¿½è¸ªæˆåŠŸ - ${state.handInfluence > 0.5 ? 'å¼ å¼€' : 'æ¡æ‹³'}`;
                hint.innerText = `æ‰©æ•£å¼ºåº¦: ${(state.handInfluence * 100).toFixed(0)}% | æ¡æ‹³ï¼šèšé›† ğŸ„`;

            } else {
                statusDot.classList.remove('active');
                statusText.innerText = "ç­‰å¾…æ‰‹åŠ¿ - Searching...";
                state.handInfluence = 0; 
                hint.innerText = "è¯·åœ¨æ‘„åƒå¤´å‰å±•ç¤ºæ‰‹æŒ (é»˜è®¤ä¸ºæ¡æ‹³æ¨¡å¼)";
            }
        }

        function onWindowResize() {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        window.toggleFullScreen = function() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                if (document.exitFullscreen) document.exitFullscreen();
            }
        };

        init();
    </script>
</body>
</html>
